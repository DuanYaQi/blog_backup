[TOC]

# 自动存储
- 在默认情况下，在函数中声明的函数参数和变量存储类型为auto，作用域为局部。
- 如果在代码块中定义了变量，则该变量的存在时间和作用域被为代码块
- 在函数体内部代码块中声明与代码块外部名称相同变量时，程序执行到代码块内部时将该变量解释为局部代码块变量，新的定义隐藏了旧的定义。程序离开代码块时，原来的定义重新可见
- 全局声明的auto变量具有外部链接性，两个源文件中不能声明同名称的全局auto变量
- 使用extern关键字引用同名外部变量

    ```cpp
    //1.cpp
    int t = 5;
    int main()
    {
        ...
    }
    
    //2.cpp
    extren int t;//t = 5
    ```

    - 注意： extern int t = 1 等效于声明赋值语句
    - 实际上，使用extern链接的外部变量是与原变量相同地址的一样的变量

# 函数存储
- 函数的默认为静态存储，具有外部链接性。static可将函数的链接性设置为内部，在其他源文件中可声明并定义同名函数
- 在定义了静态函数的文件中，静态函数的定义将覆盖全局函数的定义。即使在文件外部有同名函数仍使用静态版本。
- 内联函数不受该规则限制，在头文件中声明内联函数，包含头文件的每个文件都会具有内联函数的定义。

# 静态存储
-  使用static关键字声明的变量为静态存储变量
-  全局声明的静态变量不具有外部连接性，若其他源文件有同名自动变量，在使用时静态变量的定义将覆盖自动变量
-  静态变量的作用域与自动变量相同，但在程序运行时一直存在。在函数体内声明的静态变量声明赋值语句只会执行一次
-  使用作用域解析运算符  ::  放在变量前面时，将使用变量的全局版本

# 类作用域
- 在类中定义的函数和变量作用域为整个类。因此可以在不同类中使用相同的类成员名
- 类作用域意味着不能从外部直接访问类成员，必须通过对象访问
- 在类外定义类成员函数时需要加上作用解析运算符（如void Ch::test(int b)）
- 访问类指针成员时须使用间接成员运算符（->）
- 在类声明中不能直接定义整型常量，在类定义未声明时并不能为常量开辟储存空间。解决方法为

   ```cpp
    class a
    {
    public:
        enum{yellow = 10};
    ...
    }
   ```

    这种方式不会创建类成员，类中的对象不包含枚举。yellow是符号名称，在类中，编译器会用12替代yellow。
    - 使用关键字static const

     ```cpp
    class a
    {
    public:
        static const yellow = 12;
    ...
    }
     ```

   这种方式会创建静态类成员，但其存储在静态存储区中而非对象中